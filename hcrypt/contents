개요
이 라이브러리는 AES-GCM 기반의 암복호화 기능을 제공하며, 키 생성 시 **KDF(PBKDF2)**를 적용하여 보안을 높였습니다.

AES-GCM: 무결성 확인(인증 태그) 가능, IV(Nonce) 재사용 금지에 주의
KDF: 사용자의 평문 패스워드로부터 안전한 키를 유도. 반복 횟수(Iteration)를 높여 무차별 대입 공격을 어렵게 만듦
2. 주요 기능
AES-GCM 암/복호화

IV(Nonce): 12바이트 무작위로 생성
인증 태그: 16바이트
암호문 형식: [IV 12바이트] + [암호문] + [Tag 16바이트]
KDF(PBKDF2_HMAC_SHA256)

deriveKeyFromPassword(...)를 통해
- 패스워드 + 솔트를 입력
- keyLen(16/24/32) 및 iteration(기본 10000) 지정
- AES-128/192/256 중 자동 선택
반복 횟수를 크게 할수록 공격이 어려워지지만, 연산 시간이 증가함
민감 데이터 초기화

암/복호화가 끝난 후, std::memset으로 key/IV 등을 지우려고 시도합니다.
컴파일러 최적화 등에 의해 완벽히 제거되지 않을 수 있으므로, 실제 보안 환경에서는 더 안전한 메커니즘(예: OPENSSL_cleanse)을 사용할 수도 있습니다.
C/C++ 혼합 인터페이스

내부는 C++ 스타일로 구현
extern "C" 함수를 제공하여 C 언어, 혹은 다른 스크립트 언어(파이썬, C# 등)에서 DLL/SO를 직접 호출 가능
쓰레드 안전성

OpenSSL 1.1.0+ 버전 기준으로 내부적으로 쓰레드 락이 처리되나,
전역 초기화(opensslInit)와 정리(opensslCleanup)는 동시에 여러 스레드가 실행하지 않도록 뮤텍스로 보호함
3. 키(Password) 관리 방법
KDF + Salt

사용자는 안전하게 Salt를 보관해야 합니다. (Salt는 공개되어도 괜찮지만, 유출되지 않도록 관리하는 편이 낫습니다.)
Password(패스프레이즈)는 절대 코드/레포지토리에 하드코딩하지 말고, 안전한 방법(예: 환경 변수, 별도 안전저장)으로 관리하세요.
추가적인 조치

가능하다면 OS 레벨(Windows DPAPI, Linux Keyring)이나 HSM(하드웨어 보안 모듈)을 사용해 키나 패스워드를 보호하는 것이 좋습니다.
이 라이브러리는 메모리 상에서 암호 연산을 수행하기 때문에, 메모리 덤프나 디버거 등을 통해 키가 노출될 가능성이 완전히 사라지지는 않습니다.
4. 빌드 및 배포
Windows (Visual Studio)

DLL 프로젝트 생성 후, 이 코드 파일들을 추가
OpenSSL 라이브러리가 설치되어 있어야 하며, Include/Lib 경로를 프로젝트에 설정
컴파일하면 hcrypt_gcm_kdf.dll 생성
서버 코드(C/C++/C# 등)에서 이 DLL의 extern "C" 함수들을 호출 가능
리눅스/맥

g++ -fPIC -shared hcrypt_gcm_kdf.cpp -o libhcrypt_gcm_kdf.so -lcrypto
.so(또는 .dylib)를 서버 환경에 배포, dlopen 등을 이용하여 C 인터페이스를 활용
5. 주의사항
IV 재사용 금지: GCM 모드는 동일한 키로 동일 IV를 반복 사용하면 보안 취약점이 생깁니다. 본 코드에서는 암호화할 때마다 무작위 IV를 자동 생성하므로 문제 없지만, 암호문을 전송/저장하는 측에서 반드시 IV를 잘 보관(또는 함께 저장)해야 합니다.
태그 검증 실패 시: 복호화 시 DecryptFinal이 실패하면, 암호문이 변조되었거나 태그가 맞지 않는 것입니다.
KDF 반복 횟수: 배포 시점에 성능과 보안을 저울질해 적절히 조정하세요(예: 10,000 ~ 수십만 번).
이 코드는 예시: 실제 상용 환경에서는 더 많은 보안 고려(에러 처리, 로깅, 예외, 키 저장, HSM 사용 등)가 필요합니다.